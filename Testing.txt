Um compilador é um programa que lê um programa escrito numa linguagem - a linguagem fonte - e o traduz num programa equivalente numa outra linguagem - a linguagem alvo. Como importante parte desse processo de tradução o compilador relata a seu usuário a presença de erros no programa fonte.
(Copiar imagem)

Os primeiros compiladores começaram a surgir no início dos anos 50 através de uma grande quantidade de experimentos e implementações realizadas independetemente por diversos grupos. Muitos dos trabalhos iniciais em compilação lidavam com a tradução de fórmulas aritméticas em código de máquina.


->O Modelo de Compilação de Análise e Síntese

Existem duas partes na compilação: a análise e a síntese. A parte de análise divide o programa fonte nas partes constituintes e cria uma representação intermediária do mesmo. A de síntese contrói o programa alvo desejado, a partir da representação intermediária. Das duas, a síntese requer as técnicas mais especializadas.
Durante a análise, as operações implicadas pelo programa fonte são determinadas e registradas numa estrutura hierárquica, chamada de árvore. Frequentemente, é utilizado um tipo especial de árvore, chamado de árvore sintática, na qual cada nó representa uma operação e o filho de um nó representa o argumento da operação.
Muitas ferramentas de software que manipulam programas fonte realizam primeiro algum tipo de análise. Alguns exemplos de tais ferramentas incluem: editores de estruturas, pretty printers, verificados estáticos, interpretadores.

->O contexto de um compilador

Adicionalmente ao compilador, várias outros programas podem ser necessários para se criar um programa alvo executável. Um programa fonte pode ser dividido em módulos armazenados em arquivos separados. A tarefa de coletar esses módulos é, algumas vezes, confiada a um programa distinto, chamado de pré-processador. O pré-processador pode, também, expandir formas curtas, chamadas de macros, em enunciados da linguagem fonte.


->A análise do programa fonte

Na compilação, a análise consiste em três fases:

1. Análise linear: um fluxo de caracteres constituindo um programa é lido da esquerda para a direita e agrupado em tokens, que são sequências de caracteres tendo um significado coletivo.

2. Análise hierárquica: os caracteres ou tokens são agrupados hierarquicamente em coleções aninhadas com significado coletivo.
 
3. Análise semântica: certas verificações são realizadas a fim de se assegurar que os componentes de um programa se combinam de forma significativa.
(Copiar imagem)

Análise léxica

Num compilador, a análise linear é chamada de análise léxica ou scanning. Os espaços que separam os caracteres desses tokens são normalmente eliminados durante a análise léxica.
(Copiar exemplo)

Análise sintática

A análise hierárquica é chamada de análise gramatical ou análise sintática. Envolve o agrupamento dos tokens do programa fonte em frases gramaticais, que são usadas pelo compilador, a fim de sintetizar a saída. Usualmente, as frases gramaticais do programa fonte são representadas por uma árvore gramatical.
A estrutura hierárquica de um programa é usualmente expressa por regras recursivas. Por exemplo, poderíamos ter as seguintes regras como parte da definição de expressões:

1. Qualquer identificador é uma expressão;
2. Qualquer número é uma expressão;
3. Se E1 e E2 são expressões, então também o são E1 + E2, E1 * E2, (E1);
4. Se I é um identificador e E2 é uma expressão, então I = E2 é um enunciado.

A divisão entre a análise léxica e a sintática é um tanto arbitrária. Um fator determinante na divisão é o de uma construção da linguagem fonte ser inerentemente recursiva ou não. As construções léxicas não requerem recursão, enquanto que as sintáticas frequentemente a exigem. As gramáticas livres de contexto são uma formalização das regras recursivas que podem ser usadas para guiar a análise sintática.
Ex.: A recursão não é requerida para reconhecer identificadores, que são tipicamente cadeias de letras e dígitos, começando por uma letra.


Análise semântica

A fase da análise semântica verifica os erros semânticos no programa fonte e captura as informações de tipo para a fase subsequente de geração de código. Utiliza a estrutura hierárquica determinada pela fase de análise sintática, a fim de identificar os operadores e operandos das expressões e enunciados.
Um importante componente da análise semântica é a verificação de tipos. Nela o compilador checa se cada operador recebe os operandos que são permitidos pela especificação da linguagem fonte.


-->As fases de um compilador

Conceitualmente, um compilador opera em fases, cada uma das quais transforma o programa fonte de uma representação para outra.
(copiar imagem)
Na prática, algumas das fases podem ser agrupadas e a representação intermediária entre as mesmas não precisa ser explicitamente construída. 


Gerenciamento da tabela de símbolos

Uma função essencial do compilador é registrar os identificadores usados no programa fonte e coletar as informações sobre os seus diversos atributos. Esses atributos podem providenciar informações sobre a memória reservada para o identificador, seu tipo, escopo e, no caso de nomes de procedimentos, coisas tais como o número e os tipos de seus argumentos, o método de transmissão de cada um e o tipo retornado, se algum.
Uma tabela de símbolos é uma estrutura de dados contendo um registro para cada identificador, com campos contendo os atributos do identificador. A estrutura de dados nos permite encontrar rapidamente cada registro e, igualmente, armazenar ou recuperar dados do mesmo.
Quando, no programa fonte, o analisador léxico detecta um identificador, instala-o na tabela de símbolos. No entanto, os atributos do identificador não podem ser normalmente determinados durante a análise léxica.
As fases remanescentes colocam informações sobre os identificadores na tabela de símbolos e em seguidas as usam de várias maneiras.


Detecção de erros e geração de relatórios

Cada fase pode encontrar erros. Entretanto, após encontrá-los, precisa lidar de alguma forma com os mesmos, de tal forma que a compilação possa continuar, permitindo que sejam detectados erros posteriores no programa fonte.
As fa]ses de análise sintática e semântica tratam usualmente de uma ampla fatia dos erros detectáveis pelo compilador. A fase de análise léxica pode detectá-los quando os caracteres remanescentes na entrada não formem qualquer token da linguagem. Os erros, onde o fluxo de tokens viole as regras estruturais (sintaxe) da linguagem, são determinados pela fase de análise sintática. Durante a análise semântica, o compilador tenta detectar as construções que possuam a estrutura sintática correta, sem nenhuma preocupação com o significado da operação envolvida.
(copiar imagem)

As fases da análise

À medida que a tradução progide, a representação interna do compilador para o programa fonte muda.
A fase de análise léxica lê os caracteres de um programa fonte e os agrupa num fluxo de tokens, no qual cada token representa uma sequência de caracteres logicamente coesiva. A sequência de caracteres que formam um token é chamada de lexema para aquele token.
Certos tokens serão enriquecidos por "um valor léxico". Quando um identificador é encontrado, o analisador léxico não somente gera um token, mas também instala o lexema na tabela de símbolos, se já não estiver lá.
(tentar copiar o exemplo)


Geração de código intermediário

Após as análises sintática e semântica, alguns compiladores geram uma representação intermediária explícita do programa fonte. Podemos pensar dessa representação intermediária como um programa para uma máquina abstrata. Essa representação intermediária deveria possuir duas propriedades importantes: ser fácil de produzir e fácil de traduzir no programa alvo.

Otimização de código

A fase de otimização tenta melhorar o código intermediário de tal forma que venha resultar um código de máquina mais rápido em tempo de execução.
Existe uma grande variação na quantidade de otimizações de código que cada compilador executa. Naqueles que mais a realizam, chamados de "compiladores otimizantes", uma porção significativa de seus tempos é gasta nessa fase.


Geração de código

A fase final do compilador é a geração do código alvo, consistindo normalmente de código de máquina relocável ou código de montagem. As localizações de memória são selecionadas para cada uma das variáveis usadas pelo programa. Então, as instruções intermediárias são cada uma, traduzidas numa sequência de instruções de máquina que realizam a mesma tarefa. Um aspecto crucial é a atribuição das variáveis aos registradores.

(falar um pouco de pré-processadores)



-->Interfaces de vanguarda e retaguarda

Frequentemente, as fases são coletadas numa interface de vanguarda ou de retaguarda. A interface de vanguarda consiste naquelas fases, ou partes de fases, que dependem primariamente da linguagem fonte e são amplamente independentes da máquina alvo. Dentre esse fases são normalmente incluídas a análise léxica e a sintática, a cricação da tabela de símbolos, a análise semântica, e a geração do código intermediário. A interface de vanguarda também inclui o tratamento de erros que está associado a essas fases.
A interface de retaguarda inclui aquelas partes do compilador que dependem da máquina alvo e que, geralemente, não dependem da linguagem fonte, tão-só da linguagem intermediária. Na interface de retaguarda encontramos alguns aspectos da fases de otimização e de geração de código, juntamente com as operações de tratamento de erro e manipulação da tabela de símbolos necessárias.
Tem se tornado uma praxe tomar a interface de vanguarda de um compilador e fazer sua interface de retaguarda associada, de forma a produzir um compilador para a mesma linguagem fonte numa máquina diferente. Se a interface de retaguarda tiver sido projetada cuidadosamente, pode nem ser mesmo necessário reprojetar muito de sua interface de vanguarda. É também atraente recompilar várias diferentes linguagem na mesma linguagem intermediária e usar uma interface de retaguarda comum para as diferentes interfaces de vanguarda, obtendo vários compiladores para a mesma máquina.







